/*
dale - v4.3.3

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source.
*/

(function () {

   // *** SETUP ***

   var isNode = typeof exports === 'object';

   if (isNode) var dale = exports;
   else        var dale = window.dale = {};

   var type = function (value, objectType) {
      var type = typeof value;
      if (type !== 'object' && type !== 'number') return type;
      if (value instanceof Array) return 'array';
      if (type === 'number') {
         if      (isNaN (value))      return 'nan';
         else if (! isFinite (value)) return 'infinity';
         else if (value % 1 === 0)    return 'integer';
         else                         return 'float';
      }
      type = Object.prototype.toString.call (value).replace ('[object ', '').replace (']', '').toLowerCase ();
      if (type === 'array' || type === 'date' || type === 'null') return type;
      if (type === 'regexp') return 'regex';
      if (objectType) return type;
      return 'object';
   }

   // *** THE MAIN FUNCTION ***

   var make = function (what) {
      return function (input, second, third, fourth) {

         if      (what === 'do')              var fun = second, inherit = third  === true, output = [], index = 0;
         else if (what === 'fil')             var fun = third,  inherit = fourth === true, output = [], index = 0;
         else if (what !== 'obj')             var fun = third,  inherit = fourth === true, output;
         else if (type (second) === 'object') var fun = third,  inherit = fourth === true, output = second;
         else                                 var fun = second, inherit = third  === true, output = {};

         if (type (fun) !== 'function') {
            console.log (((what === 'do' || (what === 'obj' && type (second) !== 'object')) ? 'Second' : 'Third') + ' argument passed to dale.' + what + ' must be a function but instead is', fun, 'with type', type (fun));
            return false;
         }

         if (input === undefined) return output;

         var inputType = type (input);

         if      (inputType === 'array')  {}
         else if (inputType === 'object') {
            if (Object.prototype.toString.call (input) === '[object Arguments]') inputType = 'array', input = [].slice.call (input);
         }
         else inputType = 'array', input = [input];

         for (var key in input) {

            if (inputType === 'array') key = parseInt (key);
            else {
               if (! inherit && ! Object.prototype.hasOwnProperty.call (input, key)) continue;
            }

            var result = fun (input [key], key);

            if      (what === 'do')   output [index++] = result;
            else if (what === 'fil') {
               if (result !== second) output [index++] = result;
            }
            else if (what === 'stop') {
               if (result === second) return result;
               output = result;
            }
            else if (what === 'stopNot') {
               if (result !== second) return result;
               output = result;
            }
            else {
               if (result === undefined) continue;
               if (type (result) !== 'array') {
                  console.log ('Value returned by fun must be an array but instead is of type ' + type (result));
                  return;
               }
               output [result [0]] = result [1];
            }
         }
         return output;
      }
   }

   // *** THE EIGHT FUNCTIONS ***

   dale.do      = make ('do');
   dale.fil     = make ('fil');
   dale.obj     = make ('obj');
   dale.stop    = make ('stop');
   dale.stopNot = make ('stopNot');
   dale.keys    = function (input, inherit) {return dale.do (input, function (v, k) {return k}, inherit)};
   dale.times   = function (steps, start, step) {
      if (steps === 0) return [];
      if (type (steps) !== 'integer' || steps < 0) {
         console.log ('steps must be a positive integer or zero.');
         return;
      }
      if (start === undefined) start = 1;
      else if (type (start) !== 'integer' && type (start) !== 'float') {
         console.log ('start must be an integer or float.');
         return;
      }
      if (step  === undefined) step  = 1;
      else if (type (step) !== 'integer'  && type (step)  !== 'float') {
         console.log ('step must be an integer or float.');
         return;
      }

      var output = [start];
      while (output.length < steps) {
         start += step;
         output.push (start);
      }
      return output;
   }

   dale.acc = function (input, second, third, fourth) {
      var hasAcc  = arguments.length === (type (arguments [arguments.length - 1]) === 'boolean' ? 4 : 3);
      var acc     = hasAcc ? second : undefined;
      var fun     = hasAcc ? third  : second;
      var inherit = hasAcc ? fourth : third;
      if (type (fun) !== 'function') {
         console.log ('fun must be a function but instead is of type', type (fun));
         return false;
      }
      var first = true;
      dale.do (input, function (v, k) {
         if (! hasAcc && first) {
            first = false;
            return acc = v;
         }
         acc = fun (acc, v);
      }, inherit);

      return acc;
   }

}) ();
/*
teishi - v3.13.2

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source.
*/

(function () {

   // *** SETUP ***

   var isNode = typeof exports === 'object';

   var dale   = isNode ? require ('dale') : window.dale;

   if (isNode) var teishi = exports;
   else        var teishi = window.teishi = {};

   // *** HELPER FUNCTIONS ***

   teishi.t = function (value, objectType) {
      var type = typeof value;
      if (type !== 'object' && type !== 'number') return type;
      if (value instanceof Array) return 'array';
      if (type === 'number') {
         if      (isNaN (value))      return 'nan';
         else if (! isFinite (value)) return 'infinity';
         else if (value % 1 === 0)    return 'integer';
         else                         return 'float';
      }
      type = Object.prototype.toString.call (value).replace ('[object ', '').replace (']', '').toLowerCase ();
      if (type === 'array' || type === 'date' || type === 'null') return type;
      if (type === 'regexp') return 'regex';
      if (objectType) return type;
      return 'object';
   }

   teishi.s = function () {
      try {return JSON.stringify.apply (JSON.stringify, arguments)}
      catch (error) {return false}
   }

   teishi.p = function () {
      try {return JSON.parse.apply (JSON.parse, arguments)}
      catch (error) {return false}
   }

   teishi.simple = function (input) {
      var type = teishi.t (input);
      return type !== 'array' && type !== 'object';
   }

   teishi.complex = function (input) {
      return ! teishi.simple (input);
   }

   teishi.last = function (array) {
      if (teishi.t (array) !== 'array') return false;
      return array [array.length - 1];
   }

   teishi.c = function (input, path, seen) {

      if (teishi.simple (input)) return input;

      path = path || ['$root'];
      seen = seen || [path, input];

      var inputType = teishi.t (input, true);
      var output    = inputType === 'array' || inputType === 'arguments' ? [] : {};

      dale.do (input, function (v, k) {
         if (teishi.simple (v)) return output [k] = v;
         var circular = dale.stopNot (seen, undefined, function (v2, k2) {
            if (k2 % 2 !== 0 && v === v2) return seen [k2 - 1];
         });
         if (! circular) {
            seen.push (path.concat ([k])) && seen.push (v);
            return output [k] = teishi.c (v, path.concat ([k]), seen.concat ());
         }
         output [k] = 'CIRCULAR REFERENCE: ' + circular.join ('.');
      });

      return output;
   }

   teishi.eq = function (a, b) {
      if (teishi.simple (a) && teishi.simple (b)) return a === b;
      if (teishi.t (a, true) !== teishi.t (b, true)) return false;
      if (teishi.s (dale.keys (a).sort ()) !== teishi.s (dale.keys (b).sort ())) return false;
      return dale.stop (a, false, function (v, k) {
         return teishi.eq (v, b [k]);
      }) === false ? false : true;
   }

   teishi.time = function () {return new Date ().getTime ()}

   var lastColor, ansi = {
      end:   function () {return isNode ? '\033[0m'  : ''},
      bold:  function () {return isNode ? '\033[1m'  : ''},
      white: function () {return isNode ? '\033[37m' : ''},
      color: function (reverse) {
         if (! isNode) return '';
         var color = lastColor;
         while (lastColor === color) color = Math.round (Math.random () * 5 + 1);
         lastColor = color;
         return '\033[' + (reverse ? '4' : '3') + color + 'm';
      }
   }

   teishi.l = function () {

      var output = ansi.bold ();

      (function inner (input, depth) {

         var inputType = teishi.t (input), depth = depth || 0, first = true;

         if (inputType === 'object' && Object.prototype.toString.call (input) === '[object Arguments]') inputType = 'array';

         var indent = depth < 2 ? '' : '\n' + dale.do (dale.times (depth - 1), function (v) {return '   '}).join ('');

         if (depth > 0) {
            if (inputType === 'array')  output += ansi.white () + '[';
            else                        output += ansi.white () + '{';
         }

         dale.do (input, function (v, k) {

            var typeV = teishi.t (v);

            if (depth === 0 && k === 0 && (typeV === 'string' || typeV === 'integer')) {
               first = false;
               return output += ansi.color (true) + v + ':' + ansi.end () + ansi.bold ();
            }

            if (! first) output += ansi.white () + (depth === 0 ? ' ' : ', ');
            first = false;

            if (typeV === 'string' && depth > 0) v = "'" + v + "'";
            if (typeV === 'function') {
               v = v + '';
               var baseIndent = v.match (/\s+(?=}$)/);
               if (baseIndent !== null) v = v.replace (new RegExp (baseIndent [0], 'g'), '\n');
               if (v.length > 150) v = v.slice (0, 150) + '...\n';
               if (depth > 1) v = v.replace (/\n/g, inputType === 'array' ? indent : ('\n' + (k + ': ').replace (/./g, ' ') + indent.slice (1)));
            }

            output += ansi.color ();
            if (inputType === 'object') output += indent + (k.match (/^[0-9a-zA-Z_]+$/) ? k : "'" + k + "'") + ': ';

            if (typeV === 'array' || typeV === 'object') inner (v, depth + 1);
            else output += inputType === 'object' ? v : indent + v;
         });

         if (depth > 0) {
            if (inputType === 'array')  output += (depth > 1 ? '\n' : '') + indent.slice (4) + ansi.white () + ']';
            if (inputType === 'object') output += (depth > 1 ? '\n' : '') + indent.slice (4) + ansi.white () + '}';
         }

      }) (teishi.c (arguments));

      console.log ('(' + new Date ().toISOString () + ')', output + ansi.end ());
      return false;
   }

   teishi.lno = function () {isNode = false}

   // *** TEST FUNCTIONS ***

   teishi.makeTest = function (fun, clauses) {

      if (teishi.t (fun) !== 'function') {
         return teishi.l ('teishi.makeTest', 'fun passed to teishi.makeTest should be a function but instead is', fun, 'with type', teishi.t (fun));
      }
      if (teishi.t (clauses) === 'string') clauses = [clauses];
      if (teishi.t (clauses) !== 'array') {
         return teishi.l ('teishi.makeTest', 'clauses argument passed to teishi.makeTest should be an array but instead is', clauses, 'with type', teishi.t (clauses));
      }
      if (teishi.t (clauses [0]) !== 'string') {
         return teishi.l ('teishi.makeTest', 'shouldClause passed to teishi.makeTest should be a string but instead is', clauses [0], 'with type', teishi.t (clauses [0]));
      }

      if (clauses [1] !== undefined) {
         if (teishi.t (clauses [1]) !== 'array') clauses [1] = [clauses [1]];

         var clausesResult = dale.stopNot (clauses [1], true, function (v) {
            var type = teishi.t (v);
            if (type === 'string' || type === 'function') return true;
            return teishi.l ('teishi.makeTest', 'Each finalClause passed to teishi.makeTest should be a string or a function but instead is', v, 'with type', type);
         });
         if (clausesResult !== true) return;
      }

      return function (functionName, names, compare, to, eachValue, ofValue) {
         var result = fun (compare, to);
         if (result === true) return true;
         if (teishi.t (result) === 'array') return result;

         var error = [], index = 0;
         if (eachValue !== undefined)  error [index++] = 'each of the';
         if (names [0])                error [index++] = names [0];
         if (functionName)             error [index++] = 'passed to', error [index++] = functionName;
                                       error [index++] = clauses [0];
         if (ofValue !== undefined)    error [index++] = 'one of';
                                       error [index++] = ofValue !== undefined ? ofValue : to;
         if (names [1])                error [index++] = '(' + names [1] + ')';
                                       error [index++] = eachValue !== undefined ? 'but one of' : 'but instead';
         if (eachValue !== undefined)  error [index++] = eachValue;
                                       error [index++] = 'is';
                                       error [index++] = compare;

         dale.do (clauses [1], function (v) {
            error [index++] = typeof v !== 'function' ? v : v (compare, to);
         });
         return error;
      }
   }

   teishi.test = {

      type:     teishi.makeTest (
         function (a, b) {return teishi.t (a) === b},
         ['should have as type', ['with type', teishi.t]]
      ),

      equal:    teishi.makeTest (teishi.eq, 'should be equal to'),

      notEqual: teishi.makeTest (function (a, b) {
         return ! teishi.eq (a, b);
      }, 'should not be equal to'),

      range:    teishi.makeTest (function (a, b) {
         if (teishi.t (b, true) !== 'object') {
            return ['Range options object must be an object but instead is', b, 'with type', teishi.t (b, true)];
         }
         if (teishi.s (b) === '{}') return true;
         return dale.stopNot (b, true, function (v, k) {
            if (k !== 'min' && k !== 'max' && k !== 'less' && k !== 'more') {
               return ['Range options must be one of "min", "max", "less" and "more", but instead is', k]
            }
            if (k === 'min')  return a >= v;
            if (k === 'max')  return a <= v;
            if (k === 'less') return a < v;
                              return a > v;
         });
      }, 'should be in range'),

      match:    teishi.makeTest (function (a, b) {
         if (teishi.t (a) !== 'string') {
            return ['Invalid comparison string passed to teishi.test.match. Comparison string must be of type string but instead is', a, 'with type', teishi.t (a)];
         }
         if (teishi.t (b) !== 'regex') {
            return ['Invalid regex passed to teishi.test.match. Regex must be of type regex but instead is', b, 'with type', teishi.t (b)];
         }
         return a.match (b) !== null;
      }, 'should match')
   }

   // *** VALIDATION ***

   teishi.validateRule = function (rule) {

      var ruleType = teishi.t (rule);
      if (ruleType === 'function' || ruleType === 'boolean') return true;
      if (ruleType !== 'array') {
         return ['each teishi rule must be an array or boolean or function but instead is', rule, 'with type', ruleType];
      }

      var typeFirst = teishi.t (rule [0]);

      if (! (typeFirst === 'string' || (typeFirst === 'array' && rule [0].length === 2 && teishi.t (rule [0] [0]) === 'string' && teishi.t (rule [0] [1]) === 'string'))) return true;

      if (rule.length === 3) return true;

      if (rule.length < 3 || rule.length > 5) {
         return ['Each teishi simple rule must be an array of length between 3 and 5, but instead is', rule, 'and has length', rule.length];
      }

      var test, multi;

      var result = dale.stopNot (rule, true, function (v, k) {
         if (k < 3) return true;
         var type = teishi.t (v);
         if (type === 'string') {
            if (v !== 'oneOf' && v !== 'each' && v !== 'eachOf') return ['Invalid multi parameter', v, '. Valid multi parameters are', ['oneOf', 'each', 'eachOf']];
            if (multi) return ['You can pass only one multi parameter to a teishi simple rule but instead you passed two:', rule [3], 'and', rule [4]];
            multi = v;
         }
         else if (type === 'function') {
            if (test) return ['You can pass only one test function to a teishi simple rule but instead you passed two:', rule [3], 'and', rule [4]];
            test = v;
         }
         else return ['Elements #4 and #5 of a teishi simple rule must be either a string or a function, but element', '#' + (k + 1), 'is', v, 'and has type', type];
         return true;
      });

      return result;
   }

   // *** THE MAIN FUNCTIONS ***

   var reply = function (error, apres) {
      if (apres === undefined) return teishi.l.apply (teishi.l, ['teishi.v'].concat (error));
      error = dale.do (error, function (v) {
         return teishi.complex (v) ? teishi.s (v) : v + '';
      }).join (' ');
      if (apres === true) return error;
      apres (error);
      return false;
   }

   teishi.v = function (first, second, third) {

      if (teishi.t (first) === 'string') var functionName = first, rule = second, apres = third;
      else                               var functionName = '',    rule = first,  apres = second;

      if (apres !== undefined && apres !== true && teishi.t (apres) !== 'function') return teishi.l ('teishi.v', 'Invalid apres argument. Must be either undefined, true, or a function.');

      var validation = teishi.validateRule (rule);
      if (validation !== true) return reply (validation, apres);

      var ruleType = teishi.t (rule);
      if (ruleType === 'boolean')  return rule;
      if (ruleType === 'function') return teishi.v (functionName, rule (), apres);

      if (rule.length === 0) return true;

      var ruleFirstType = teishi.t (rule [0]);
      if (ruleFirstType === 'boolean' && rule.length === 2 && teishi.t (rule [1]) === 'array') {
         if (rule [0] === false) return true;
         else return teishi.v (functionName, rule [1], apres);
      }

      if (! (ruleFirstType === 'string' || (ruleFirstType === 'array' && rule [0].length === 2 && teishi.t (rule [0] [0]) === 'string' && teishi.t (rule [0] [1]) === 'string'))) {
         return dale.stopNot (rule, true, function (rule) {
            return teishi.v (functionName, rule, apres);
         });
      }

      var typeFourth = teishi.t (rule [3]), typeFifth = teishi.t (rule [4]);
      var test  = typeFourth === 'function' ? rule [3] : (typeFifth === 'function' ? rule [4] : teishi.test.type);
      var multi = typeFourth === 'string'   ? rule [3] : (typeFifth === 'string'   ? rule [4] : undefined);

      var result;
      var names = ruleFirstType === 'array' ? rule [0] : [rule [0]];

      var typeCompare = teishi.t (rule [1], true), typeTo = teishi.t (rule [2], true);

      if ((multi === 'each' || multi === 'eachOf') && ((typeCompare === 'array' && rule [1].length === 0) || (typeCompare === 'object' && Object.keys (rule [1]).length === 0) || rule [1] === undefined)) {
         return true;
      }

      if ((multi === 'oneOf' || multi === 'eachOf') && ((typeTo === 'array' && rule [2].length === 0) || (typeTo === 'object' && Object.keys (rule [2]).length === 0) || rule [2] === undefined)) {
         result = ['To field of teishi rule is', rule.to, 'but multi attribute', multi, 'requires it to be non-empty, at teishi step', rule];
      }

      else if (multi === undefined) {
         result = test (functionName, names, rule [1], rule [2]);
      }

      else if (multi === 'each') {
         result = dale.stopNot (rule [1], true, function (v) {
            return test (functionName, names, v, rule [2], rule [1]);
         });
      }

      else if (multi === 'oneOf') {
         result = dale.stop (rule [2], true, function (v) {
            return test (functionName, names, rule [1], v, undefined, rule [2]);
         });
      }

      else {
         result = dale.stopNot (rule [1], true, function (v) {
            return dale.stop (rule [2], true, function (v2) {
               return test (functionName, names, v, v2, rule [1], rule [2]);
            });
         });
      }

      if (result === true) return true;
      else return reply (result, apres);

   }

   teishi.stop = function () {
      return teishi.v.apply (teishi.v, arguments) === true ? false : true;
   }

}) ();
/*
lith - v4.5.3

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source.
*/

(function () {

   // *** SETUP ***

   var isNode = typeof exports === 'object';

   var dale   = isNode ? require ('dale')   : window.dale;
   var teishi = isNode ? require ('teishi') : window.teishi;

   if (isNode) var lith = exports;
   else        var lith = window.lith = {};

   var type = teishi.t, log = teishi.l;

   // *** CONSTANTS ***

   lith.k = {
      lithbagElements: ['string', 'integer', 'float', 'array', 'undefined'],
      tags: ['!DOCTYPE HTML', 'LITERAL', 'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'map', 'mark', 'menu', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'],
      voidTags: ['!DOCTYPE HTML', 'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']
   }

   /*
   if (teishi.stop ([['HTML void tags', 'HTML tags'], lith.k.voidTags, lith.k.tags, 'eachOf', teishi.test.equal])) {
      return false;
   }
   */

   // *** HELPER FUNCTIONS ***

   lith.entityify = function (string, prod) {
      if (! prod && teishi.stop ('lith.entityify', ['Entityified string', string, 'string'])) return false;

      return string
         .replace (/&/g, '&amp;')
         .replace (/</g, '&lt;')
         .replace (/>/g, '&gt;')
         .replace (/"/g, '&quot;')
         .replace (/'/g, '&#39;')
         .replace (/`/g, '&#96;');
   }

   // *** LITH VALIDATION ***

   lith.v = function (input) {

      var inputType = type (input);

      if (inputType === 'array' && type (input [0]) === 'string' && lith.k.tags.indexOf (input [0]) !== -1) {

         var attributes = type (input [1]) === 'object' ? input [1] : undefined;
         var contents   = input [attributes ? 2 : 1];

         return teishi.v ([
            ['lith length', input.length, {min: 1, max: 3}, teishi.test.range],
            [attributes === undefined, ['length of lith without attributes', input.length, {max: 2}, teishi.test.range]],
            [
               ['lith attribute keys', 'start with an ASCII letter, underscore or colon, and be followed by letters, digits, underscores, colons, periods, dashes, extended ASCII characters, or any non-ASCII characters.'],
               dale.keys (attributes),
               /^[a-zA-Z_:][a-zA-Z_:0-9.\-\u0080-\uffff]*$/,
               'each', teishi.test.match
            ],
            ['lith attribute values', attributes, ['string', 'integer', 'float', 'undefined', 'null', 'boolean'], 'eachOf'],
            ['lith contents', contents, lith.k.lithbagElements, 'oneOf']
         ], function (error) {
            log ('lith.v - Invalid lith', {error: error, 'original input': input});
         }) ? 'Lith' : false;
      }

      return teishi.v ([
         ['lithbag', inputType, lith.k.lithbagElements, 'oneOf', teishi.test.equal],
         [inputType === 'array', ['lithbag elements', input, lith.k.lithbagElements, 'eachOf']]
      ], function (error) {
         log ('lith.v - Invalid lithbag', {error: error, 'original input': input});
      }) ? 'Lithbag' : false;
   }

   // *** LITH GENERATION ***

   lith.g = function (input, prod) {

      if (prod || lith.prod) {
         if ((prod || lith.prod) !== true) return log ('lith.g', 'prod or lith.prod must be true or undefined.');
         if (type (input) === 'array' && lith.k.tags.indexOf (input [0]) !== -1) {
            return lith.generateLith (input, true);
         }
         return lith.generateLithbag (input, false, true);
      }

      var inputType = lith.v (input);

      return inputType ? lith ['generate' + inputType] (input) : false;
   }

   lith.generateLithbag = function (lithbag, dontEntityify, prod) {

      var output = '';

      if (dale.stop (lithbag, false, function (v) {

         if (v === undefined) return;

         var typeV = type (v);

         if (type (v) !== 'array') return output += (dontEntityify ? v : lith.entityify (v + '', prod));

         if (prod) output += lith.g (v, prod);
         else {
            var recursiveOutput = lith.g (v, prod);
            if (recursiveOutput === false) return false;
            else output += recursiveOutput;
         }

      }) === false) return false;

      return output;
   }

   lith.generateLith = function (input, prod) {

      var attributes = type (input [1]) === 'object' ? input [1] : undefined;
      var contents   = input [attributes ? 2 : 1];

      if (input [0] === 'LITERAL') return contents;

      var output = '<' + input [0];

      dale.do (attributes, function (v, k) {
         if (v || v === 0) output += ' ' + lith.entityify (k + '', prod) + '="' + lith.entityify (v + '', prod) + '"';
      });

      output += '>';

      if (type (contents) === 'array') {
         if (prod) output += input [0] === 'style' ? lith.css.g (contents) : lith.g (contents, prod);
         else {
            var recursiveOutput = input [0] === 'style' ? lith.css.g (contents) : lith.g (contents);
            if (recursiveOutput === false) return false;
            output += recursiveOutput;
         }
      }
      else output += lith.generateLithbag (contents, ((input [0] === 'style' || input [0] === 'script') ? true : false), prod);

      if (lith.k.voidTags.indexOf (input [0]) === -1) output += '</' + input [0] + '>';

      return output;
   }

   // *** CSS ***

   lith.css = {};

   // *** LITC VALIDATION ***

   lith.css.v = function (input) {

      if (teishi.stop (['litc or litcbag', input, 'array'], function (error) {
         log ('lith.css.v - Invalid litc or litcbag', {error: error, 'original input': input});
      })) return false;

      if (input.length === 0 || type (input [0]) === 'array') return true;

      var attributes = type (input [1]) === 'object' ? input [1] : undefined;
      var contents   = input [attributes ? 2 : 1];

      return teishi.v ([
         ['litc length', input.length, {min: 1, max: 3}, teishi.test.range],
         [attributes === undefined, ['length of litc without attributes', input.length, {max: 2}, teishi.test.range]],
         ['litc selector', input [0], 'string'],
         lith.css.vAttributes (attributes),
         [input [0] !== 'LITERAL', ['litc contents', contents, ['undefined', 'array'], 'oneOf']]
      ], function (error) {
         log ('lith.css.v - Invalid litc', {error: error, 'original input': input});
      });
   }

   lith.css.vAttributes = function (attributes) {
      return teishi.v ([
         ['litc attribute values', attributes, ['string', 'integer', 'float', 'object', 'undefined', 'null', 'boolean'], 'eachOf'],
      ]);
   }

   // *** LITC GENERATION ***

   lith.css.g = function (input, selector) {

      if (lith.css.v (input) === false) return false;

      if (input.length === 0) return '';

      var output = '';

      if (input [0] === 'LITERAL') return input [1];

      if (type (input [0]) === 'array') {
         if (dale.stop (input, false, function (v, k) {
            var recursiveOutput = lith.css.g (v, selector);
            if (recursiveOutput === false) return false;
            output += recursiveOutput;
         }) === false) return false;
         else return output;
      }

      if (selector === undefined) selector = '';

      var attributes = type (input [1]) === 'object' ? input [1] : undefined;
      var contents   = input [attributes ? 2 : 1];

      selector = dale.do (selector.split (/,\s*/), function (v) {
         return dale.do (input [0].split (/,\s*/), function (v2) {
            if (v2.match (/&/)) return v2.replace ('&', v);
            else                return v + (v.length === 0 ? '' : ' ') + v2;
         }).join (', ');
      }).join (', ');

      output += selector + '{';

      var addAttributes = function (attributes) {
         if (lith.css.vAttributes (attributes) === false) return false;
         return dale.stop (attributes, false, function (v, k) {
            if (! v && v !== 0) return;
            var typeV = type (v);
            if (typeV === 'object') return addAttributes (v);
            if (typeV === 'integer' && (v < 0 || v > 1)) v += 'px';
            if (typeV === 'float' || v === 1) v = (v * 100) + '%';
            dale.do (k.split (/,\s*/), function (v2) {
               output += v2 + ':' + v + ';';
            });
         });
      }

      if (addAttributes (attributes) === false) return false;

      output += '}';

      if (contents) {
         var recursiveOutput = lith.css.g (contents, selector);
         if (recursiveOutput === false) return false;
         else output += recursiveOutput;
      }

      return output;
   }

   // *** MEDIA QUERIES ***

   lith.css.media = function (selector, litc) {
      if (teishi.stop (['selector', selector, 'string'])) return false;
      return [['LITERAL', '@media ' + selector + ' {'], litc, ['LITERAL', '}']];
   }

}) ();
/*
recalc - v3.8.2

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source.
*/

(function () {

   // *** SETUP ***

   var isNode = typeof exports === 'object';

   var dale   = isNode ? require ('dale')   : window.dale;
   var teishi = isNode ? require ('teishi') : window.teishi;
   var type   = teishi.t, log = teishi.l;

   // *** CONSTRUCTOR ***

   var main = function (store) {

      if (teishi.stop ([
         ['store', store, ['array', 'object', 'undefined'], 'oneOf']
      ])) return;

      // *** FRONTEND ***

      var r = {};

      r.routes  = {};
      r.store   = store || {};

      r.do = function () {

         var x = type (arguments [0]) === 'object' ? arguments [0] : undefined;
         var verb = arguments [x ? 1 : 0];
         var path = arguments [x ? 2 : 1];

         if (teishi.simple (path)) path = [path];
         var args = [x || {}, verb, path].concat ([].slice.call (arguments, x ? 3 : 2));

         if (teishi.stop ('r.do', [
            [x !== undefined, [function () {
               return [
                  ['x.from', x.from, ['array', 'object', 'undefined'], 'oneOf'],
                  [type (x.from) === 'array', [function () {
                     return ['x.from', x.from, 'object', 'each'];
                  }]],
               ];
            }]],
            ['verb', verb, 'string'],
            r.isPath (path, 'r.do')
         ])) return false;

         r.mill.apply (null, args);
         return true;
      }

      r.listen = function () {

         var options, rfun = arguments [arguments.length - 1];
         if (arguments.length < 2) return log ('r.listen', 'Too few arguments passed to r.listen');
         if (arguments.length === 2) options = arguments [0];
         else {
            options      = arguments.length === 3 ? {} : arguments [2];
            options.verb = arguments [0];
            options.path = arguments [1];
         }

         if (teishi.simple (options.path)) options.path = [options.path];

         if (teishi.stop ('r.listen', [
            ['options',   options, 'object'],
            ['keys of options', dale.keys (options), ['verb', 'path', 'id', 'parent', 'priority', 'burn', 'match'], 'eachOf', teishi.test.equal],
            function () {return [
               ['options.verb', options.verb, ['string', 'regex'], 'oneOf'],
               r.isPath (options.path, 'r.listen', true),
               ['options.id',       options.id,       ['string', 'integer', 'undefined'], 'oneOf'],
               ['options.parent',   options.parent,   ['string', 'integer', 'undefined'], 'oneOf'],
               ['options.priority', options.priority, ['undefined', 'integer'],           'oneOf'],
               ['options.burn',     options.burn,     ['undefined', 'boolean'],           'oneOf'],
               ['options.match',    options.match,    ['undefined', 'function'], 'oneOf']
            ]},
            ['route function', rfun, 'function']
         ])) return false;

         if (options.id) {
            if (r.routes [options.id]) return log ('r.listen', 'A route with id', options.id, 'already exists.');
         }
         else options.id = r.random ();
         options.rfun = rfun;

         r.routes [options.id] = options;
         return options.id;
      }

      r.forget = function (id, fun) {
         if (fun !== undefined && type (fun) !== 'function') return log ('Second argument to r.forget must be a function or undefined.');
         if (! r.routes [id]) return log ('Route', id, 'does not exist.');
         var route = r.routes [id];
         delete r.routes [id];
         if (fun) fun (route);
         dale.do (r.routes, function (v, k) {
            if (v.parent === id) r.forget (k, fun);
         });
      }

      // *** BACKEND ***

      r.isPath = function (path, fun, regex) {
         return teishi.v (fun, [
            ['path', path, ['array', 'integer', 'string'].concat (regex ? 'regex' : []), 'oneOf'],
            ['path', path,          ['integer', 'string'].concat (regex ? 'regex' : []), 'eachOf'],
         ]);
      }

      r.random = function () {
         return Math.random ().toString (16).slice (2);
      }

      r.compare = function (rvp, evp) {
         if (rvp === '*' || evp === '*') return true;
         if (type (rvp) === 'regex') return (evp + '').match (rvp) !== null;
         return rvp === evp;
      }

      r.mill = function (x, verb, path) {

         var from;
         if (! x.from)                        from = [];
         else if (type (x.from) === 'object') from = [x.from];
         else                                 from = x.from.slice (0);

         from.unshift ({date: new Date ().toISOString (), verb: verb, path: path});

         var args = [{verb: arguments [1], path: arguments [2], from: from}].concat ([].slice.call (arguments, 3));
         if (arguments.length > 3) {
            args [0].args = [].slice.call (arguments, 3);
            from [0].args = [].slice.call (arguments, 3);
         }

         var inner = function (matchingRoutes) {

            if (matchingRoutes.length === 0) return;
            args [0].cb = function () {
               inner (matchingRoutes);
            }

            var route = matchingRoutes.shift ();
            args [0].route = route;
            if (! r.routes [route.id]) return inner (matchingRoutes);
            if (route.burn) r.forget (route.id);
            if (type (route.rfun.apply (null, args)) !== 'function') inner (matchingRoutes);
         }

         inner (r.sort (r.match (verb, path, r.routes)));
      }

      r.match = function (verb, path, routes) {

         var matching = [];

         dale.do (routes, function (route) {

            if (route.match) return route.match (route, {verb: verb, path: path}) === true ? matching.push (route) : undefined;

            if (! r.compare (route.verb, verb)) return;

            if (route.path.length > path.length) return;

            if (route.path.length === 0) return matching.push (route);

            if (dale.stop (route.path, false, function (v2, k2) {
               return r.compare (v2, path [k2]);
            })) matching.push (route);

         });

         return matching;
      }

      r.sort = function (matching) {
         return matching.sort (function (a, b) {
            return (b.priority || 0) - (a.priority || 0);
         });
      }

      return r;
   }

   if (isNode) module.exports  = main;
   else        window.R        = main;

}) ();
/*
cocholate - v1.6.6

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source (but not yet!).
*/

(function () {

   // *** SETUP ***

   if (typeof exports === 'object') return console.log ('cocholate only works in a browser!');

   var dale   = window.dale;
   var teishi = window.teishi;

   var type   = teishi.t;

   // *** CORE ***

   var c = window.c = function (selector, fun) {
      if (teishi.stop ('c', ['fun', fun, ['function', 'undefined'], 'oneOf'])) return false;

      var elements = c.find (selector);
      if (elements === false) return false;

      if (fun) {
         var args = teishi.c (arguments).slice (2);
         elements = dale.do (elements, function (v) {
            return fun.apply (undefined, [v].concat (args));
         });
      }

      if (type (selector) === 'string' && selector.match (/^[a-z]*#[^\s\[>,:]+$/)) return elements [0];
      else                                                                         return elements;
   }

   c.nodeListToArray = function (nodeList) {
      // https://davidwalsh.name/nodelist-array
      return [].slice.call (nodeList);
   }

   c.setop = function (operation, set1, set2) {
      if (operation === 'and') return dale.fil (set1, undefined, function (v) {
         return set2.indexOf (v) !== -1 ? v : undefined;
      });
      var output = set1.slice ();
      if (operation === 'or') {
         dale.do (set2, function (v) {
            if (output.indexOf (set2) === -1) output.push (v);
         });
      }
      else {
         if (output.length === 0) output = c.nodeListToArray (document.getElementsByTagName ('*'));
         dale.do (set2, function (v) {
            var index = output.indexOf (v);
            if (index !== -1) output.splice (index, 1);
         });
      }
      return output;
   }

   c.find = function (selector) {

      var selectorType = type (selector);

      if (teishi.stop ('cocholate', [
         ['selector', selector, ['array', 'string', 'object'], 'oneOf'],
         function () {return [
            [selectorType === 'array',  ['first element of array selector', selector [0], [':and', ':or', ':not'], 'oneOf', teishi.test.equal]],
            [selectorType === 'object', [
               ['selector keys', dale.keys (selector), ['selector', 'from'], 'eachOf', teishi.test.equal],
               ['valid HTML node', selector.from, 'undefined', teishi.test.notEqual],
               function () {return [['from.querySelectorAll', 'valid HTML node'], selector.from.querySelectorAll, 'function']}
            ]]
         ]}
      ])) return false;

      if (selectorType === 'string') return c.nodeListToArray (document.querySelectorAll (selector));
      if (selectorType === 'object') return c.nodeListToArray (selector.from.querySelectorAll (selector.selector));

      var operation = selector.shift ();
      var output = [];

      dale.stop (selector, false, function (v, k) {
         var elements = c.find (v);
         if (elements === false) return output = false;
         if (k === 0 && operation !== ':not') output = elements;
         else                                 output = c.setop (operation.replace (':', ''), output, elements);
      });
      return output;
   }

   // *** DOM OPERATIONS ***

   c.empty = function (selector) {
      c (selector, function (element) {
         dale.do (c.nodeListToArray (element.getElementsByTagName ('*')), function (v) {
            v.remove ();
         });
      });
   }

   c.fill = function (selector, html) {
      if (teishi.stop ('c.fill', ['html', html, 'string'])) return false;

      c.empty (selector);
      c (selector, function (element) {
         element.innerHTML = html;
      });
   }

   c.place = function (selector, where, html) {
      if (teishi.stop ('c.place', [
         ['where', where, ['beforeBegin', 'afterBegin', 'beforeEnd', 'afterEnd'], 'oneOf', teishi.test.equal],
         ['html', html, 'string']
      ])) return false;

      c (selector, function (element) {
         element.insertAdjacentHTML (where, html);
      });
   }

   c.get  = function (selector, attributes, css) {
      if (teishi.stop ('c.get', ['attributes', attributes, ['string', 'array'], 'oneOf'])) return false;

      return c (selector, function (element) {
         return dale.obj (attributes, function (v) {
            if (css) return [v, element.style [v] || null];
            else     return [v, element.getAttribute (v)];
         });
      });
   }

   c.set  = function (selector, attributes, css, notrigger) {
      if (teishi.stop ('c.set', [
         ['attributes', attributes, 'object'],
         [
            ['attribute keys', 'start with an ASCII letter, underscore or colon, and be followed by letters, digits, underscores, colons, periods, dashes, extended ASCII characters, or any non-ASCII characters.'],
            dale.keys (attributes),
            /^[a-zA-Z_:][a-zA-Z_:0-9.\-\u0080-\uffff]*$/,
            'each', teishi.test.match
         ],
         ['attribute values', attributes, ['integer', 'string', 'null'], 'eachOf']
      ])) return false;

      c (selector, function (element) {
         dale.do (attributes, function (v, k) {
            if       (css)        element.style [k] = v === null ? '' : v;
            else if  (v === null) element.removeAttribute (k);
            else                  element.setAttribute    (k, v);
         });
         if (element.onchange && ! notrigger) element.onchange ();
      });
   }

   // *** NON-DOM OPERATIONS ***

   c.ready = function (fun) {
      if (document.addEventListener) return document.addEventListener ('DOMContentLoaded', fun);
      // http://stackoverflow.com/questions/799981/document-ready-equivalent-without-jquery
      if (document.attachEvent) {
         document.attachEvent ('onreadystatechange', function () {
            if (document.readyState === 'complete') fun ();
         });
      }
      else fun ();
   }

   c.cookie = function (cookie) {
      if (cookie === false) {
         return dale.do (document.cookie.split (/;\s*/), function (v) {
            // https://stackoverflow.com/a/27374365
            document.cookie = v.replace (/^ +/, '').replace (/=.*/, '=;expires=' + new Date ().toUTCString ())
            return v;
         });
      }
      return dale.obj ((cookie || document.cookie).split (/;\s*/), function (v) {
         if (v === '') return;
         v = v.split ('=');
         var name = v [0];
         var value = v.slice (1).join ('=');
         return [name, value];
      });
   }

   c.ajax = function (method, path, headers, body, callback) {
      method   = method   || 'GET';
      body     = body     || '';
      headers  = headers  || {};
      callback = callback || function () {};
      if (teishi.stop ('c.ajax', [
         ['method',   method,   'string'],
         ['path',     path,     'string'],
         ['headers',  headers,  'object'],
         ['callback', callback, 'function']
      ])) return false;

      var r = new XMLHttpRequest ();
      r.open (method.toUpperCase (), path, true);
      if (teishi.complex (body) && teishi.t (body, true) !== 'formdata') {
         headers ['content-type'] = headers ['content-type'] || 'application/json';
         body = teishi.s (body);
      }
      dale.do (headers, function (v, k) {
         r.setRequestHeader (k, v);
      });
      r.onreadystatechange = function () {
         if (r.readyState !== 4) return;
         if (r.status !== 200)   return callback (r);
         var json;
         var res = {
            xhr: r,
            headers: dale.obj (r.getAllResponseHeaders ().split ('\r\n'), function (header) {
               header = header.split (/:\s+/);
               if (header [0].match (/^content-type/i) && header [1].match ('application/json')) json = true;
               return header;
            })
         };
         res.body = json ? teishi.p (r.responseText) : r.responseText;
         callback (null, res);
      }
      r.send (body);
      return {headers: headers, body: body, xhr: r};
   }

   // *** POLYFILL ***

   c.polyfill = function () {

      var newElement = function () {
         return document.createElement ('_');
      }

      // https://gist.github.com/eligrey/1276030
      if (! newElement ().insertAdjacentHTML) {

         HTMLElement.prototype.insertAdjacentHTML = function (position, html) {

            var This = this, container = newElement (), Parent = This.parentNode, node, firstChild, nextSibling;

            container.innerHTML = html;

            if      (position === 'beforeBegin') {
               while (node = container.firstChild) Parent.insertBefore (node, This);
            }
            else if (position === 'afterBegin') {
               firstChild = This.firstChild;
               while (node = container.lastChild)  This.insertBefore (node, firstChild);
            }
            else if (position === 'beforeEnd') {
               while (node = container.firstChild) This.appendChild (node);
            }
            else {
               nextSibling = This.nextSibling;
               while (node = container.lastChild)  Parent.insertBefore (node, nextSibling)
            }
         }
      }

      // https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
      if (! Element.prototype.remove) {
         Element.prototype.remove = function () {
            if (this.parentNode) this.parentNode.removeChild (this);
         }
      }

      if (! Array.prototype.indexOf) {
         Array.prototype.indexOf = function (element, from) {
            var result = dale.stopNot (from ? this.slice (from) : this, undefined, function (v, k) {
               if (element === v) return k;
            });
            return result === undefined ? -1 : result;
         }
      }
   }

   c.polyfill ();

}) ();
/*
gotoB - v1.2.4

Written by Federico Pereiro (fpereiro@gmail.com) and released into the public domain.

Please refer to readme.md to read the annotated source (but not yet!).
*/

(function () {

   // *** SETUP ***

   if (typeof exports === 'object') return console.log ('gotoB only works in a browser!');

   var dale = window.dale, teishi = window.teishi, lith = window.lith, R = window.R, c = window.c, B = window.B;

   var type = teishi.t, log = teishi.l;

   var r = window.R ();
   var B = window.B = {v: '1.2.4', B: 'в', r: r, routes: r.routes, store: r.store, do: r.do, listen: r.listen, forget: r.forget};

   // *** B.EVENTLOG ***

   B.eventlog = [];

   B.listen ({id: 'eventlog', verb: '*', path: []}, function (x) {
      B.eventlog.unshift ({verb: x.verb, path: x.path, from: x.from});
      if (arguments.length > 1) B.eventlog [0].args = [].slice.call (arguments, 1);
      if (B.verbose) log ('B.eventlog event #' + B.eventlog.length, B.eventlog [0]);
   });

   // *** ARGS ***

   B.add = function (path) {

      if (! B.prod && ! r.isPath (path, 'B.add')) return false;

      if (B.get (path) === undefined) B.set (path, []);
      var target = B.get (path);
      if (type (target) !== 'array') return log ('B.add', 'Cannot add to something that is not an array.');
      dale.do (arguments, function (arg, k) {
         if (k !== 0) target.push (arg);
      });
      return true;
   }

   B.rem = function (path) {

      if (! B.prod && ! r.isPath (path, 'B.rem')) return false;

      var target     = B.get (path);
      var targetType = type (target);
      var keys       = type (arguments [1]) === 'array' ? arguments [1] : dale.do (arguments, function (v) {return v}).slice (1);

      if (! B.prod && teishi.stop ([
         ['target', target, ['array', 'object'], 'oneOf'],
         targetType === 'array' ?
            ['keys of array target',  keys, 'integer', 'each'] :
            ['keys of object target', keys, 'string',  'each']
      ])) return false;

      if (targetType === 'array') {
         keys.sort (function (a, b) {return b - a});
         dale.do (keys, function (v) {target.splice (v, 1)})
      }
      else dale.do (keys, function (v) {delete target [v]});

      return true;
   }

   B.get = function (path) {

      path = type (path) === 'array' ? path : dale.do (arguments, function (v) {return v});
      if (! B.prod && ! r.isPath (path, 'B.get')) return;

      var target = B.store;

      return dale.stop (path, false, function (v, k) {
         if (k + 1 < path.length && teishi.simple (target [v])) return false;
         target = target [v];
      }) === false ? undefined : target;
   }

   B.set = function (path, value, overwriteParent) {

      if (! B.prod && ! r.isPath (path, 'B.set')) return false;

      var target = B.store;

      if (type (path) !== 'array') path = [path];

      var error = dale.stop (path, true, function (v, k) {
         if (k + 1 === path.length) {
            target [v] = value;
            return;
         }
         var targetType = type (path [k + 1]) === 'string' ? 'object' : 'array';
         if (type (target [v]) !== targetType) {
            if (target [v] !== undefined && ! overwriteParent) {
               log ('B.set didn\'t overwrite a parent because of type mismatch. Pass a truthy third argument to force this behavior. Path', path);
               return true;
            }
            target [v] = targetType === 'object' ? {} : [];
         }
         target = target [v];
      });

      return error ? false : true;
   }

   dale.do (['add', 'rem', 'set'], function (v) {
      B.listen ({id: v, verb: v, path: []}, function (x, value) {
         if (x.verb === 'set') var prev = B.get (x.path);
         if (B [x.verb].apply (null, [x.path].concat ([].slice.call (arguments, 1))) !== true) return;
         if (x.verb === 'add' || x.verb === 'rem') {
            B.do (x, 'change', x.path);
            var args = [].slice.call (arguments, 1);
            if (x.verb === 'add') dale.do (dale.times (args.length, B.get (x.path).length - args.length), function (i) {
               B.do (x, 'change', x.path.concat (i));
            });
            if (x.verb === 'rem') {
               if (type (args [0]) === 'array') args = args [0];
               dale.do (args, function (i) {
                  B.do (x, 'change', x.path.concat (i));
               });
            }
         }
         if (x.verb === 'set' && ! teishi.eq (prev, value)) B.do (x, 'change', x.path);
      });
   });

   // *** DOM METHODS ***

   B.str = function (input) {
      var inputType = type (input);
      if (teishi.simple (input)) return inputType === 'string' ? JSON.stringify (input) : (input + '');

      var output = inputType === 'array' ? '[' : '{';

      if (inputType === 'array') output += dale.do (input, B.str).join (', ');
      else                       output += dale.do (input, function (v, k) {
         return JSON.stringify (k) + ': ' + B.str (v);
      }).join (', ');

      output += inputType === 'array' ? ']' : '}';

      return output;
   }

   B.ev = function () {

      var attrs = arguments.length === 1 ? {} : arguments [0];
      var evs   = arguments.length === 1 ? arguments [0] : arguments [1];

      if (type (evs) === 'array' && type (evs [0]) === 'string') evs = [evs];

      if (! B.prod && teishi.stop ('B.ev', [
         ['attrs', attrs, 'object'],
         ['evs',   evs,   'array'],
         ['evs',   evs,   'array', 'each'],
         function () {return dale.do (evs, function (ev) {
            return [
               ['ev.ev',   ev [0], 'string'],
               ['ev.verb', ev [1], 'string'],
               r.isPath (ev [2], 'B.ev')
            ];
         })}
      ])) return false;

      var Evs = {}, Attrs = teishi.c (attrs);
      dale.do (evs, function (ev) {
         dale.do (ev [0].split (/,\s*/), function (evname) {
            if (! Evs [evname]) Evs [evname] = [ev];
            else                Evs [evname].push (ev);
         });
      });

      return dale.obj (Evs, attrs, function (ev, evname) {
         var output = '';
         dale.do (ev, function (entry) {
            var args = [JSON.stringify (entry [1]), JSON.stringify (entry [2])];
            if (entry.length < 4) entry [3] = {rawArgs: 'this.value'};
            dale.do (entry.slice (3), function (arg) {
               if (type (arg) === 'object') {
                  var keys = dale.keys (arg);
                  if (keys.indexOf ('args') === -1 && keys.indexOf ('rawArgs') === -1) args = args.concat (B.str (arg));
                  else {
                     if (keys.indexOf ('args') !== -1)    {
                        if (type (arg.args) === 'object' || arg.args === undefined) arg.args = [arg.args];
                        args = args.concat (dale.do (arg.args, B.str));
                     }
                     if (keys.indexOf ('rawArgs') !== -1) args = args.concat (arg.rawArgs);
                  }
               }
               else args = args.concat (B.str (arg));
            });
            output += 'B.do ({from: {ev: "' + evname + '", attrs: ' + B.str (Attrs) + '}}, ' + args.join (', ') + ');';
         });
         return [evname, output];
      });
   }

   B.view = function () {
      var argc = 0;
      var x      = type (arguments [argc]) === 'object' ? arguments [argc++] : {};
      var path   = arguments [argc++];
      var params = type (arguments [argc]) === 'object' ? arguments [argc++] : {};
      var rfun   = arguments [argc];

      if (! B.prod && teishi.stop ('B.view', [
         r.isPath (path, 'B.view'),
         ['rfun',   rfun,   'function'],
         function () {return [
            ['params.tag',      params.tag, [undefined].concat (lith.k.tags), 'oneOf', teishi.test.equal],
            ['params.attrs',    params.attrs,    ['object',   'undefined'], 'oneOf'],
            ['params.listen',   params.listen,   ['array',    'undefined'], 'oneOf'],
            ['params.ondraw',   params.ondraw,   ['function', 'undefined'], 'oneOf'],
            ['params.onforget', params.onforget, ['function', 'undefined'], 'oneOf'],
            function () {
               return [params.attrs !== undefined, ['params.attrs.id', (params.attrs || {}).id, 'undefined']]
            }
         ]}
      ])) return false;

      params.attrs = params.attrs || {};
      var id = params.attrs.id = 'в' + B.count++;
      params.attrs ['path-в'] = path.join ? path.join (':') : path;

      if (params.listen && params.listen.length !== 0 && type (params.listen [0]) !== 'array') params.listen = [params.listen];

      var listeners = [];

      if (dale.stop (params.listen, false, function (args, k) {
         var routeId = dale.stopNot (args, undefined, function (arg) {
            if (type (arg) === 'object' && arg.id) return arg.id;
         });
         if (routeId) return log ('B.view', 'Cannot pass `id` property in args to listener.');
         var route = B.listen.apply (null, args);
         if (! B.prod && route === false) {
            log ('B.view', 'There was an error creating event listener #' + (k + 1) + ' on view with path: ', path);
            dale.do (listeners, function (route) {B.forget (route)});
            return false;
         }
         listeners.push (route);
         if (! B.routes [route].parent) B.routes [route].parent = id;
      }) === false) return false;

      B.listen ('change', path, {id: id, priority: -1}, function (x) {
         B.resolve (x, id, function () {
            x.from.unshift ({ev: 'redraw', id: id, path: path});
            return B.drawView (x, B.get (path), rfun);
         });
      });

      var x2 = dale.obj (x, {verb: 'change', path: path}, function (v, k) {return [k, v]});

      var view = B.drawView (x2, B.get (path), rfun);

      if (params.ondraw)   B.routes [id].ondraw   = params.ondraw;
      if (params.onforget) B.routes [id].onforget = params.onforget;
                           B.routes [id].view     = view [0];

      dale.do (B.getChildren (view [1]), function (v) {
         B.routes [v].priority--;
         if (! B.routes [v].parent) B.routes [v].parent = id;
      });

      return [params.tag || 'div', params.attrs, ['LITERAL', view [1]]];
   }

   B.mount = function (target, view) {

      if (! B.prod && type (target) !== 'string' || ! target.match (/^(body|#[^\s]+)$/)) return log ('B.mount', 'target must be either \'body\' or an id selector, but instead is ' + target);

      if (! B.prod && c (target) === undefined) return log ('B.mount', 'target not found.');

      view = lith.g (view, B.prod);

      if (! B.prod && view === false) return log ('B.mount', 'received invalid view.');

      c.place (target, 'afterBegin', view);

      dale.do (B.getChildren (view), function (id) {
         if (B.routes [id] && B.routes [id].ondraw) B.routes [id].ondraw ({from: [{ev: 'mount', target: target}], route: B.routes [id]});
      });
   }

   B.unmount = function (target) {

      if (! B.prod && type (target) !== 'string' || ! target.match (/^(body|#[^\s]+)$/)) return log ('B.unmount', 'target must be either \'body\' or an id selector, but instead is ' + target);

      var Target = target === 'body' ? c (target) [0] : c (target);

      if (! B.prod && ! Target) return log ('B.unmount', 'target not found.');

      var onforget = function (route) {
         if (route.onforget) route.onforget ({from: [{ev: 'unmount', target: target}], route: route});
      }

      var ids = B.getChildren (Target.innerHTML);

      dale.do (ids, function (id) {
         if (B.routes [id]) B.forget (id, onforget);
      });

      dale.do (ids, function (id) {
         var e = document.getElementById (id);
         if (e) e.remove ();
      });
   }

   // *** B.VIEW INTERNALS ***

   B.drawView = function (x, value, rfun) {

      var view = rfun (x, value);
      var html = lith.g (view, B.prod);

      if (! B.prod && html === false) {
         view = ['pre', ['Invalid lith: ', teishi.simple (view) ? view.toString () : JSON.stringify (view, null, '   ')]];
         html = lith.g (view, B.prod);
      }

      return [view, html];
   }

   B.getChildren = function (view) {
      var children = (view || '').match (/id="в[0-9a-f]+/g) || [];
      return dale.do (children, function (v) {
         return v.slice (4);
      });
   }

   B.count        = 1;
   B.trample      = 200;
   B.resolvequeue = [];
   B.resolving    = false;
   B.perflogs     = false;

   B.resolve = function (x, id, newView, rec) {

      if (B.resolving && ! rec) return B.resolvequeue.push ([x, id, newView]);

      B.resolving = true;

      var outro = function () {
         var next;
         var index = dale.stopNot (B.resolvequeue, undefined, function (v, k) {
            if (B.routes [v [1]]) return k;
         });

         if (index !== undefined) {
            next = B.resolvequeue [index];
            B.resolvequeue.splice (0, index + 1);
            return B.resolve.apply (null, next.concat (true));
         }
         else B.resolving = false;
      }

      if (B.perflogs) var perf = {start: teishi.time ()};

      var route = B.routes [id], newView = newView ();
      if (B.perflogs) perf.draw = teishi.time () - perf.start;

      var rootElement = document.getElementById (id);

      var onforget = function (route) {
         if (route.onforget) route.onforget (x);
      }

      if (! rootElement) {
         log ('B.resolve', 'Attempted to redraw dangling view, omitting redraw & deleting route.', {route: {id: id, path: route.path}, view: newView [0]});
         x.from.unshift ({ev: 'danglingView'});
         B.forget (id, onforget);
         return outro ();
      }

      if (B.perflogs) var difft = teishi.time ();
      var diff = B.diff (B.prediff (route.view), B.prediff (newView [0]));
      if (B.perflogs) perf.diff = teishi.time () - difft;

      dale.do (B.routes, function (route) {
         if (route.parent === id && route.id.match (/^в[0-9a-f]+$/)) B.forget (route.id, onforget);
      });

      if (diff === false) {
         if (! B.prod) log ('diff took too long, trampling instead!', route.id);
         c ('#' + id).innerHTML = newView [1];
      }
      else {
         var insert = function (el, where, position) {
            var p = find (where, 'insert1', position);
            if (p) p.parentNode.insertBefore (el, p);
            else   find (where.slice (0, where.length - 1), 'insert2', position).appendChild (el);
         }

         var find = function (where, action, position) {
            var cur = rootElement;
            dale.do (where, function (v, k) {
               if (! cur) {
                  var data = {
                     action: action,
                     position: position,
                     diffitem: diff [position].slice (0, 2).join (' '),
                     id: id,
                     where: where,
                     k: k,
                     innerHTML: rootElement.innerHTML,
                     expectedHTML: newView [1],
                     oldView: route.view,
                     newView: newView [0],
                     diff: dale.obj (teishi.c (diff), function (v2, k2) {return [k2, v2]})
                  };
                  x.from.unshift ({ev: 'gotoB error', data: data});
                  log ('gotoB redraw error! This could be caused by two things: 1) invalid markup; 2) a gotoB redraw bug. To eliminate the possibility of #1, check that the view being redrawn returns lith that represents valid HTML, taking particular care to not nest elements incorrectly (for example, an <h1> cannot go inside an <h1>). If you need help debugging the error, please open a pull request at http://github.com/fpereiro/gotoB/issues and paste the text below:\n', JSON.stringify (data, null, '   '));
                  throw new Error ('gotoB redraw error!');
               }
               cur = cur.childNodes [v];
            });
            return cur;
         }

         var dold = [0], dnew = [0], match = {
            add: {tag: null, index: null},
            rem: {tag: null, index: null}
         };

         dale.do (diff, function (v, k) {
            if (v [1].match (/^<opaque/)) return;
            if (! v [1].match (/^>/)) diff [k] [2] = {el: find (dold, 'sequence', k), old: teishi.c (dold), New: teishi.c (dnew)};
            if (v [1].match (/^</)) {
               diff [k] [2].active = diff [k] [2].el === document.activeElement;
               var tag  = v [1].match (/[^\s]+/g) [0];
               var opaque = v [1].match (/<.+ {.*"opaque":true.*}/);
               if (v [0] === 'add' && ! opaque) {
                  if (match.rem.tag === tag) {
                     diff [k] [2].match = match.rem.index;
                     diff [match.rem.index] [2].match = k;
                     match.rem.tag = match.rem.index = null;
                  }
                  else {
                     match.add.tag   = tag;
                     match.add.index = k;
                  }
               }
               if (v [0] === 'rem' && ! opaque) {
                  if (match.add.tag === tag) {
                     diff [k] [2].match = match.add.index;
                     diff [match.add.index] [2].match = k;
                     match.add.tag = match.add.index = null;
                  }
                  else {
                     match.rem.tag   = tag;
                     match.rem.index = k;
                  }
               }

               if (v [0] !== 'add') dold.push (0);
               if (v [0] !== 'rem') dnew.push (0);
            }
            else if (v [1].match (/^>/)) {
               if (v [0] !== 'add') {
                  dold.pop ();
                  dold [dold.length - 1]++;
               }
               if (v [0] !== 'rem') {
                  dnew.pop ();
                  dnew [dnew.length - 1]++;
               }
            }
            else {
               if (v [0] !== 'add') dold [dold.length - 1]++;
               if (v [0] !== 'rem') dnew [dnew.length - 1]++;
            }
         });

         var detached = {}, active, selected = [], unselected = [], checked = [], textareas = [];

         dale.do (diff, function (v, k) {
            if (v [1].match (/^>/)) return;
            if (v [1].match (/^<opaque/)) {
               if (v [0] === 'rem') return;
               // previous might be n items behind if there are multiple `rem` operations
               var previous = dale.stopNot (dale.times (k, k - 1, -1), undefined, function (k) {
                  if (diff [k] [0] !== 'rem') return diff [k];
               });
               return previous [2].el.innerHTML = v [1].slice (7);
            }
            if (v [1] [0] !== '<' && v [0] !== 'rem' && v [2].New.length > 1) {
               var Parent = find (v [2].New.slice (0, -1));
               if (Parent.tagName === 'TEXTAREA') textareas.push ([Parent, v [1]]);
            }
            if (v [0] === 'keep') {
               if (v [1].match (/<.+ {.*"opaque":true.*}/)) v [2].el.innerHTML = '';

               // This if is because of the way IE/Edge treat text elements (they simply bring text instead of a textNode).
               if (! v [2].el) insert (document.createTextNode (v [1]), v [2].New, k);
               else {
                  if (v [1].match (/<option/)) {
                     var attrs = JSON.parse (v [1].match (/{.+/) || '{}');
                     if (attrs.selected) selected.push (v [2].el);
                  }
                  insert (v [2].el.parentNode.removeChild (v [2].el), v [2].New, k);

                  if (v [2].active && v [1].match (/[^<\s]+/g) [0] !== 'a') active = v [2].el;
               }
            }
            else if (v [1].match (/^</)) {
               if (v [0] === 'rem') {
                  if (v [2].match === undefined || v [2].match > k) detached [v [2].old] = v [2].el.parentNode.removeChild (v [2].el);
               }
               if (v [0] === 'add') {
                  var el;
                  if (v [2].match !== undefined) {
                     var old = diff [v [2].match];
                     if (! detached [old [2].old]) detached [old [2].old] = old [2].el;
                     el = old [2].el;
                     var oldAttrs = dale.obj (el.attributes, function (v) {
                        // The check for v is required in FF22, IE<=10 & Opera<=11.6
                        if (v && v.specified) return [v.name, v.value];
                     });
                     var newAttrs = JSON.parse (v [1].match (/{.+/) || '{}');
                     dale.do (dale.fil (oldAttrs, undefined, function (v, k) {
                        if (type (v) === 'string') v = {name: k};
                        if (newAttrs [v.name] === undefined) return v.name;
                     }), function (k) {
                        el.removeAttribute (k);
                        if (['value', 'checked', 'selected'].indexOf (k) !== -1) el [k] = k === 'value' ? '' : false;
                        if (k === 'selected') unselected.push (el);
                     });
                     dale.do (newAttrs, function (v, k) {
                        el.setAttribute (k, v);
                        if (['value', 'checked', 'selected'].indexOf (k) !== -1) el [k] = v;
                     });
                     if (el.attributes && el.attributes.selected) selected.push (el);
                     if (el.attributes && el.attributes.checked)  checked.push  (el);
                  }
                  else {
                     el = document.createElement (v [1].match (/[^<\s]+/g) [0]);
                     dale.do (JSON.parse (v [1].match (/{.+/) || '{}'), function (v, k) {
                        if (v || v === '' || v === 0) el.setAttribute (k, v);
                     });
                  }
                  insert (el, v [2].New, k);
                  v [2].el = el;
                  if (old && old [2].active && v [1].match (/[^<\s]+/g) [0] !== 'a') active = el;
               }
            }
            else {
               if (v [0] === 'add') {
                  v [1] = v [1]
                     .replace (/&amp;/g,  '\&')
                     .replace (/&lt;/g,   '<')
                     .replace (/&gt;/g,   '>')
                     .replace (/&quot;/g, '"')
                     .replace (/&#39;/g,  "'")
                     .replace (/&#96;/g,  '`');
                  insert (document.createTextNode (v [1]), v [2].New, k);
               }
               else {
                  if (v [2].el) v [2].el.parentNode.removeChild (v [2].el);
               }
            }
            if (v [1].match (/<textarea/) && v [0] !== 'rem') textareas.push ([v [2].el]);
         });

         if (active) {
            active.focus ? active.focus () : active.setActive ();
            active.blur ();
            active.focus ? active.focus () : active.setActive ();
         }

         dale.do (selected,   function (el) {el.selected = true});
         dale.do (unselected, function (el) {el.selected = false});
         dale.do (checked,    function (el) {el.checked  = true});

         var Textareas = dale.fil (textareas, undefined, function (v) {
            if (v.length === 2) return v [0];
         });

         dale.do (textareas, function (v) {
            if (v.length === 2) return v [0].value = v [1].replace (/&amp;/g, '&').replace (/&lt;/g, '<').replace (/&gt;/g, '>').replace (/&quot;/g, '"').replace (/&#39;/g, "'").replace (/&#96;/g, '`');
            if (Textareas.indexOf (v [0]) === -1) v [0].value = '';
         });
      }

      route.view = newView [0];

      dale.do (B.getChildren (c ('#' + id).innerHTML), function (id) {
         var croute = B.routes [id];
         croute.priority += route.priority;
         if (! croute.parent) croute.parent = route.id;
         if (croute.ondraw) croute.ondraw (x);
      });

      if (route.ondraw) route.ondraw (x);

      if (B.perflogs) {
         perf.total = teishi.time () - perf.start;
         log ('gotoB redraw performance', id, B.routes [id].path, perf);
      }
      outro ();
   }

   B.prediff = function (input, output) {

      if (teishi.simple (input)) {
         if (input === undefined || input === '') return output ? undefined : [];
         if (! output) return [lith.g (input, B.prod)];
         if (output.length === 0) output.push ('');
         if (output [output.length - 1].match (/^(<|>)/)) output.push ('');
         return output [output.length - 1] += lith.g (input, B.prod);
      }

      output = output || [];

      if (lith.k.tags.indexOf (input [0]) !== -1) {
         output.push ('<' + input [0]);

         var attrs = type (input [1]) !== 'object' ? undefined : dale.obj (input [1], function (v, k) {
            if (v || v === 0) return [k, v];
         });

         var conts = input [attrs ? 2 : 1];
         if (input [0] === 'style' && type (conts) === 'array') conts = lith.css.g (conts);
         if (attrs) {
            output [output.length - 1] += ' ' + JSON.stringify (attrs);
            if (attrs.opaque) output.push ('<opaque' + lith.g (conts, B.prod));
            else if (attrs.id !== undefined && (attrs.id + '').match (/^в[0-9a-f]+$/g)) {
               conts = B.routes [attrs.id].view;
            }
         }
         var mark = output.length;
         if (! attrs || ! attrs.opaque) B.prediff (conts, output);
         if (input [0] === 'table' && output [mark]) {
            if (output [mark].match (/<thead/)) {
               var deep = 0;
               var index = dale.stopNot (dale.times (output.length - mark, mark), undefined, function (k) {
                  if (output [k].match (/</)) deep++;
                  if (output [k].match (/>/)) deep--;
                  if (deep === 0) return mark = k + 1;
               });
            }
            if (output [mark] && output [mark].match (/<tbody/) === null) {
               output.splice (mark, 0, '<tbody');
               output.push ('>');
            }
         }
         output.push ('>');
      }
      else {
         dale.do (input, function (v) {
            B.prediff (v, output);
         });
      }
      return output;
   }

   B.diff = function (s1, s2) {

      var V = [], sol, d = 0, vl, vc, k, out, y, point, diff, v, last, t = Date.now ();

      while (d < s1.length + s2.length + 1) {

         if (B.trample && (Date.now () - t > B.trample)) return false;

         vl = V [V.length - 1] || {1: [0, 0]};
         vc = {};
         V.push (vc);

         k = -d;

         while (k < -d + 2 * d + 1) {

            if (k === -d || (k !== d && vl [k - 1] [1] < vl [k + 1] [1])) out = [0, vl [k + 1] [1]];
            else                                                          out = [0, vl [k - 1] [1] + 1, true];

            y = out [1] - k;

            while (out [1] < s1.length && y < s2.length && s1 [out [1]] === s2 [y]) {
               out [1]++; y++; out [0]++;
            }

            vc [k] = out;

            if (out [1] < s1.length || y < s2.length) {
               k += 2;
               continue;
            }

            point = {x: out [1], y: y};
            diff  = [];

            v = d;

            while (v > -1) {
               last = V [v] [point.x - point.y];
               y = last [1] - (point.x - point.y);
               if (last [0]) dale.do (dale.times (last [0]), function (v2) {
                  diff.unshift (['keep', s1 [last [1] - v2]]);
               });
               if (last [2]) diff.unshift (['rem', s1 [last [1] - last [0] - 1]]);
               else          diff.unshift (['add', s2 [y        - last [0] - 1]]);
               point.x = last [1] - last [0] - (last [2] ? 1 : 0);
               point.y = y        - last [0] - (last [2] ? 0 : 1);
               v--;
            }

            diff.shift ();
            return diff;
         }
         d++;
      }
   }

}) ();
